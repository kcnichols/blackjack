import React from "react";
import S2SBaseComponent from "s2s-base-class";
// import ObjectMerge from "object-merge";
import PropTypes from "prop-types";
import { colorGrid } from "s2s-themes";
import { fromJS } from 'immutable';
import * as svgIcons from 's2s-svg-icons';
import styled from 'styled-components';
//import { injectIntl } from 'react-intl';

const icons = { ...svgIcons };

const ButtonTemplate = styled.button`
    align-items: center;
    background-color : ${ props => props.bgColorDefault};
    border-color: transparent;
    border-radius: ${ props => props.buttonShape === "rectangle" ? ' 4px' : '100%'};
    border-width: 1px;
    cursor: pointer;
    display: inline-flex; // Using this over flex so that button does not stretch out to fill it's container - KCN
    flex-direction: ${ props => props.svgPosition === 'left' ? `row` : `row-reverse`};
    height : ${ props => props.height}; // Corrected height issue not being passed down correctly. Found when using button in Login component - KCN
    padding-bottom : ${props => props.buttonShape === "round" ? '4px' : '0px'}; // circular buttons come off looking more circular and not like a weird oval - KCN
    padding-top : ${props => props.buttonShape === "round" ? ' 4px' : '0px'}; // circular buttons come off looking more circular and not like a weird oval - KCN
    padding-left : ${props => props.buttonType === 'icon' ? '8px' : '16px'}; 
    padding-right : ${props => props.buttonType === 'icon' ? '8px' : '16px'}; 
    outline: none;
    user-select: none;

    /** Styling based on Button States **/
    &:hover { 
        background-color: ${props => props.bgColorHover}; 
    }
    &:focus { 
        border-color : ${colorGrid.blue5};
        /* box shadow exists on all s2s form elements is necessary to indicate active state and override default browser settings. Color value is a colorGrid value in rgba format with .6 opacity */
        -webkit-box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
        -moz-box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
        box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
    }

    &:disabled {
        opacity : 0.6;
        outline: none;
        cursor : not-allowed;
    }
`;

const LabelTemplate = styled.div`
    align-items: center;
    color : ${ props => props.fontColor};
    display: flex;
    font-size : 14px;
    line-height : 16px;
    margin-left : ${ props => {
    if (props.hasSVG === true) {
      return props.svgPosition === 'left' ? '8px' : '0px';
    }
  }};
    margin-right : ${ props => {
    if (props.hasSVG === true) {
      return props.svgPosition === 'left' ? '0px' : '8px';
    }
  }};
    text-align: center;
`;

class Button extends S2SBaseComponent {
  constructor(props) {
    super(props);
    this.displayName = "Button";

    this.state = {
      isHover: false
    };

    this.renderSVG = this.renderSVG.bind(this);
    this.getStylesBasedOnType = this.getStylesBasedOnType.bind(this);
    this.getStylesBasedOnSize = this.getStylesBasedOnSize.bind(this);
    this.handleMouseEnter = this.handleMouseEnter.bind(this);
    this.handleMouseLeave = this.handleMouseLeave.bind(this);

  }

  static propTypes = {
    ariaLabel: PropTypes.string,
    buttonLabel: PropTypes.string,
    buttonSize: PropTypes.oneOf(["small", "medium", "large"]),
    buttonShape: PropTypes.oneOf(["round", "rectangle"]),
    buttonType: PropTypes.oneOf(["primaryRed", "primaryGreen", "primaryBlue", "secondary", "outline", "ghost", "flux", "icon"]),
    cbClick: PropTypes.func,
    compStyle: PropTypes.object,
    svgFill: PropTypes.string,
    svgType: PropTypes.string,
    svgPosition: PropTypes.oneOf(["left", "right"]),
    isDisabled: PropTypes.bool
  };

  static defaultProps = {
    ariaLabel: "ariaLabel is not defined",
    buttonLabel: undefined,
    buttonShape: "rectangle",
    buttonSize: "medium",
    buttonType: "primaryRed",
    cbClick: () => { console.log("Default callback function"); },
    compStyle: {},
    isDisabled: false,
    svgFill: "currentColor",
    svgType: undefined,
    svgPosition: "left"
  };

  static filename = 's2s-button';
  static displayName = 'Button';

  shouldComponentUpdate(nextProps, nextState) {
    return !fromJS(nextProps).equals(fromJS(this.props)) || !fromJS(nextState).equals(fromJS(this.state));
  }

  getStylesBasedOnType() {

    let stylesBasedOnType;
    switch (this.props.buttonType) {
      case 'primaryRed':
        stylesBasedOnType = {
          'bgColorDefault': colorGrid.red6,
          'bgColorHover': colorGrid.red8,
          'fontColor': colorGrid.gray0,
          'borderColor': 'transparent'
        };
        break;
      case 'primaryBlue':
        stylesBasedOnType = {
          'bgColorDefault': colorGrid.blue6,
          'bgColorHover': colorGrid.blue8,
          'fontColor': colorGrid.gray0,
          'borderColor': 'transparent'
        };
        break;
      case 'primaryGreen':
        stylesBasedOnType = {
          'bgColorDefault': colorGrid.green6,
          'bgColorHover': colorGrid.green8,
          'fontColor': colorGrid.gray0,
          'borderColor': 'transparent'
        };
        break;
      case 'secondary':
        stylesBasedOnType = {
          // TODO : this.props.theme doesn't exist right now. So it is blowing up the app. Uncomment code once themeing is implemented
          // 'bgColorDefault': this.props.theme.bg,
          // 'bgColorHover': this.props.theme.bghover,
          // 'fontColor': this.props.theme.fg,
          'borderColor': '#979797'
        };
        break;
      case 'icon':
        stylesBasedOnType = {
          // TA - for now, use gray2 for default, gray4 for hover, gray5 for font/fill, gray8 for hover fill...
          'bgColorDefault': colorGrid.gray4,
          'bgColorHover': colorGrid.gray2,
          'fillColor': colorGrid.gray5,
          'fillColorHover': colorGrid.gray8,
          'height': '40px',
          'padding': '0px 8px'
        };

        break;
      case 'outline':
      case 'ghost':
      default:
        stylesBasedOnType = {
          'bgColorDefault': 'inherit',
          'bgColorHover': 'inherit',

        };
    }

    return stylesBasedOnType;
  }

  getStylesBasedOnSize() {
    let stylesBasedOnSize;

    if (this.props.buttonType === 'icon') {
      return ({
        'buttonHeight': '40px'
      });
    }

    switch (this.props.buttonSize) {
      case 'small':
        stylesBasedOnSize = {
          'buttonHeight': '24px'
        };
        break;
      case 'medium':
        stylesBasedOnSize = {
          'buttonHeight': '32px'
        };
        break;
      case 'large':
        stylesBasedOnSize = {
          'buttonHeight': '40px'
        };
        break;
      default:
        stylesBasedOnSize = {
          'buttonHeight': 'inherit'
        };
    }

    return stylesBasedOnSize;
  }

  handleMouseEnter() {
    this.setState((prevState) => {
      return { ...prevState, isHover: true };
    });
  }

  handleMouseLeave() {
    this.setState((prevState) => {
      return { ...prevState, isHover: false };
    });
  }


  /*
    NAME: renderSVG
    DESCRIPTION: A function that checks if {this.props.svgType} exists in our component library.
    If so it renders the JSX for that SVG dynamically. 
    ARGUMENTS: None.
    RETURN: Returns JSX for an SVG in our component library.
    CALLED: Called in the render method.
  */
  renderSVG() {
    let displaySvg;

    if (this.props.svgType && icons.hasOwnProperty(this.props.svgType)) {
      const DynamicSVG = icons[this.props.svgType];

      if (this.props.buttonType === 'icon') {
        const svgStyles = this.getStylesBasedOnType('icon');
        displaySvg = (
          <DynamicSVG
            className={this.props.svgType}
            svgStyle={{
              fill: this.state.isHover ? svgStyles.fillColorHover : svgStyles.fillColor,
              height: '24px',
              width: '24px'
            }}
          />);
      } else {
        displaySvg = (
          <DynamicSVG
            className={this.props.svgType}
            svgStyle={{
              fill: this.props.svgFill,
              height: this.props.buttonSize === 'large' ? '32px' : '24px',
              width: this.props.buttonSize === 'large' ? '32px' : '24px'
            }}
          />);
      }
    }

    return displaySvg;

  }

  render() {

    return (
      <ButtonTemplate
        aria-label={this.props.ariaLabel}
        className={`Button Container ${this.props.className} `}
        bgColorDefault={this.getStylesBasedOnType().bgColorDefault}
        bgColorHover={this.getStylesBasedOnType().bgColorHover}
        borderColor={this.getStylesBasedOnType().borderColor}
        buttonShape={this.props.buttonShape}
        buttonType={this.props.buttonType}
        height={this.getStylesBasedOnSize().buttonHeight}
        disabled={this.props.isDisabled}
        svgPosition={this.props.svgPosition}
        onClick={this.props.cbClick}
        tabIndex={0}
        onMouseEnter={this.handleMouseEnter}
        onMouseLeave={this.handleMouseLeave}
      >
        {this.renderSVG()}
        {this.props.buttonLabel !== undefined && this.props.buttonType !== 'icon' ?
          <LabelTemplate
            buttonSize={this.props.buttonSize}
            buttonType={this.props.buttonType}
            fontColor={this.getStylesBasedOnType().fontColor}
            hasSVG={this.props.svgType !== undefined ? true : false}
            isDisabled={this.props.isDisabled}
            svgPosition={this.props.svgPosition}
          >
            {this.props.buttonLabel}
          </LabelTemplate> : undefined
        }
      </ButtonTemplate>
    );
  }
}

export default Button;
// BY KC Nichols - 05/16/2018