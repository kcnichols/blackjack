import React from 'react';
import S2SBaseComponent from "s2s-base-class";
import { fromJS } from "immutable";
import ObjectMerge from "object-merge";
import { colorGrid } from 's2s-themes';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { AlertIconSVG } from 's2s-svg-icons';
import ReactSelect from 'react-select';

const SelectContainer = styled.div`
  height : 100%;
  margin-right : 24px;
  width : 100%;
`;


const SelectLabel = styled.div`
  color : inherit;
  display : ${props => props.showSelectLabel ? 'flex' : 'none'};
  flex-direction : column;
  font-size : 14px;
  font-weight : 600;
  line-height : 14px;
  margin-bottom : 8px;
  user-select : none;
  width : 100%;
`;


// Parent div of <ErrorSVGArea /> and <ErrorText />
const ErrorContainer = styled.div`
    align-items: center;
    background-color : ${colorGrid.red7};
    border-radius : 4px;
    box-shadow: 0px 4px 8px rgba(33, 37, 41, 0.4);
    color : ${colorGrid.gray0};
    display : flex;
    font-size : 14px;
    line-height : 16px;
    padding : 8px 12px;
    z-index : 3;

    // styling necessary for positioning to <Container />
    // position : absolute;
    top : ${(props) => {

    let topPosition = '55px'; // has neither hint or a label

    if (props.hasLabel || props.hasHint) {
      topPosition = '69px';
    }

    if (props.hasLabel && props.hasHint) {
      topPosition = '77px';
    }
    return topPosition;
  }}; 
    width : calc(100% - 22px ); // must account for padding left/right of <ErrorContainer />  and border of <StyledInput /> or it is not the full width
`;

class Select extends S2SBaseComponent {
  constructor(props) {
    super(props);
    this.state = {
      isSelectOpen: false,
      selectedItem: this.props.selectedItem ? this.props.selectedItem : "",
      isFocus: false,
      filteredItems: this.props.menuItems
    };
    this.displayName = 'Select';

    //this.renderMenuItems = this.renderMenuItems.bind(this);
    this.selectClicked = this.selectClicked.bind(this);
    this.menuItemClicked = this.menuItemClicked.bind(this);
    //this.menuItemKeyDown = this.menuItemKeyDown.bind(this);
    this.selectKeyPress = this.selectKeyPress.bind(this);
    //this.getCaretSVG = this.getCaretSVG.bind(this);
    //this.selectedItemClick = this.selectedItemClick.bind(this);
    //this.selectedItemKeyPress = this.selectedItemKeyPress.bind(this);
    this.handleFocus = this.handleFocus.bind(this);
    this.handleBlur = this.handleBlur.bind(this);

  }

  static propTypes = {
    //openAbove: PropTypes.bool,
    isDisabled: PropTypes.bool,
    menuItems: PropTypes.array,
    cbOnValueChange: PropTypes.func,
    cbOnBlur: PropTypes.func,
    selectLabel: PropTypes.string,
    selectedItem: PropTypes.any,
    //itemsVisible: PropTypes.number,
    placeholder: PropTypes.string,
    showSelectLabel: PropTypes.bool
  };

  static defaultProps = {
    //openAbove: false,
    isDisabled: false,
    cbOnValueChange: () => { console.log("cbOnValueChange is not defined"); },
    cbOnBlur: () => { console.log('cbOnBlur is not defined'); },
    selectedItem: "",
    selectLabel: undefined,
    //itemsVisible: 3,
    placeholder: "Please select a value",
    showSelectLabel: true
  };


  shouldComponentUpdate(nextProps, nextState) {
    return !fromJS(nextProps).equals(fromJS(this.props)) || !fromJS(nextState).equals(fromJS(this.state));
  }

  getSelectedItemIndex(menuitems) {


    const selectedIndex = menuitems.reduce((previous, current, index) => {
      if (!previous) {

        if (current.value === this.state.selectedItem) {
          return index;
        }
      }
      return previous;
    }, undefined);

    return selectedIndex;
  }

  selectClicked() {

    if (this.props.isDisabled === false) {
      this.setState((prevState) => {
        return { ...prevState, isSelectOpen: !this.state.isSelectOpen };
      });
    }

  }

  selectKeyPress(e) {
    //console.log('kkkkk', e, e.keyCode, e.key,  e.charCode);
    if (e.charCode > 0 || e.charCode < 123) {
      const myKeyText = e.key;
      // console.log('find first one ', e.key );
      let bFound = false;
      let fItem;
      const sItem = this.props.menuItems.reduce((p, c) => {
        if (!p) {
          //console.log(c.label.toLowerCase()[0], e.key.toLowerCase() );
          if (c.label.toLowerCase().substring(0, myKeyText.length) === myKeyText.toLowerCase()) {
            if (!fItem) {
              fItem = c.value;
            }
            if (c.value !== this.state.selectedItem) {
              //console.log('SSSSS', this.state.selectedItem, bFound, c.label, c.value);
              if (!this.state.selectedItem || this.state.selectedItem && bFound) {
                return c.value;
              }
            } else {
              bFound = true;
            }
          }
        }
        return p;
      }, undefined);
      let filteredItems = this.props.menuItems.filter((item) => {
        return item.label.toLowerCase().substring(0, myKeyText.length) === myKeyText.toLowerCase();
      });

      //console.log('sssss', sItem, fItem, this.state.selectedItem,  myKeyText, filteredItems, filteredItems.length);
      if (sItem) {
        this.setState((prevState) => {
          return { ...prevState, selectedItem: sItem, "filteredItems": filteredItems, isSelectOpen: true };
        });

      } else if (fItem) {
        this.setState((prevState) => {
          return { ...prevState, selectedItem: fItem, "filteredItems": filteredItems, isSelectOpen: true };
        });
      } else {
        this.setState((prevState) => {
          return { ...prevState, selectedItem: fItem, "filteredItems": this.props.menuItems, isSelectOpen: true };
        });
      }

    }
    if (e.charCode == 13) {
      this.setState((prevState) => {
        return { ...prevState, "filteredItems": this.props.menuItems, isSelectOpen: !this.state.isSelectOpen };
      });
    }
  }

  menuItemClicked(item) {
    this.setState((prevState) => {
      return { ...prevState, selectedItem: item.value, "filteredItems": this.props.menuItems, isSelectOpen: false };
    });
    //console.log('xxxxx', item, this.props );
    // adding doValidate if we have errorText so they clear errorText
    if (this.props.errorText && this.props.errorText.length > 0) {
      item.doValidate = true;
    } else {
      item.doValidate = false;
    }
    this.props.cbOnValueChange(item);
  }

  // menuItemKeyDown(e, item) {
  //   if (e.charCode == 13) {
  //     this.setState((prevState) => {
  //       return { ...prevState, selectedItem: item.value, "filteredItems": this.props.menuItems, isSelectOpen: false };
  //     });
  //     this.props.cbOnValueChange(item);
  //   }
  // }

  // selectedItemClick() {
  //   this.setState((prevState) => {
  //     return { ...prevState, keyText: "", "filteredItems": this.props.menuItems, isSelectOpen: false };
  //   });
  // }

  // selectedItemKeyPress(e) {
  //   if (e.charCode == 13) {
  //     this.setState((prevState) => {
  //       return { ...prevState, isSelectOpen: false };
  //     });
  //   }
  // }

  handleFocus() {
    if (!this.props.isDisabled) {
      this.setState((prevState) => {
        return ObjectMerge(
          {},
          prevState,
          {
            'isFocus': true
          }
        );
      });
    }
  }

  handleBlur() {
    if (!this.props.isDisabled) {
      this.setState((prevState) => {
        return ObjectMerge(
          {},
          prevState,
          {
            'isFocus': false
          }
        );
      });
      this.props.cbOnBlur(this.state.selectedItem);
    }
  }

  // renderMenuItems(menuItems, selectedItemIndex) {
  //   //console.log('render menu items', menuItems);
  //   return menuItems.map((item, index) => {

  //     let menuItem;
  //     if (index === selectedItemIndex) {
  //       menuItem = <SelectedMenuItem tabIndex={0} role="button" key={item.label + index} onClick={this.selectedItemClick} onKeyPress={this.selectedItemKeyPress}>{item.label}</SelectedMenuItem>;
  //     } else {
  //       menuItem = <SelectMenuItem key={item.label + index} text={item.label} item={item} onItemClick={this.menuItemClicked} onItemKeyPress={this.menuItemKeyDown} />;
  //     }
  //     return menuItem;
  //   });
  // }

  // Render the error area
  renderErrorArea() {

    if (this.props.hasError === true && this.props.errorText !== undefined && this.state.isFocus === false) {
      return (
        <ErrorContainer
          className="ErrorContainer"
          hasLabel={this.props.inputLabel !== undefined}
          hasHint={this.props.inputHint !== undefined}
        >
          <AlertIconSVG
            className="AlertIconSVG"
            svgStyle={{
              fill: colorGrid.gray0,
              height: '24px',
              width: '24px',
              paddingRight: '12px'
            }}
          />

          <span className="ErrorText">{this.props.errorText}</span>
        </ErrorContainer>
      );
    }
  }

  // //If you know of a better way to do this please let me know! CS
  // getCaretSVG() {
  //   let caretSVG;
  //   let caretUp = <CaretUpIconSVG svgStyle={{ height: '16px', marginRight: '12px', width: '16px', fill: colorGrid.gray9 }} />;
  //   let caretDown = <CaretDownIconSVG svgStyle={{ height: '16px', marginRight: '12px', width: '16px', fill: colorGrid.gray9 }} />;

  //   if (this.state.isSelectOpen) {
  //     if (this.props.openAbove) {
  //       caretSVG = caretDown;
  //     } else {
  //       caretSVG = caretUp;
  //     }
  //   } else {
  //     if (this.props.openAbove) {
  //       caretSVG = caretUp;
  //     } else {
  //       caretSVG = caretDown;
  //     }
  //   }
  //   return caretSVG;
  // }

  render() {
    //onst dynamicSVG = this.getCaretSVG();
    //const selectedItemIndex = this.getSelectedItemIndex(this.props.menuItems);

    //console.log('select props', this.props.errorText);

    //const selectMenuHeight = Math.min(this.props.menuItems.length * MENU_ITEM_HEIGHT, this.props.itemsVisible * MENU_ITEM_HEIGHT);
    return (
      <SelectContainer className={this.props.className} >
        <SelectLabel showSelectLabel={this.props.showSelectLabel}>{this.props.selectLabel}</SelectLabel>
        <ReactSelect options={this.props.menuItems}
          onBlur={this.handleBlur}
          onFocus={this.handleFocus}
          onChange={this.menuItemClicked} isDisabled={this.props.isDisabled}
          value={this.props.menuItems.filter((i) => i.value === this.props.selectedItem)}
          placeholder={this.props.placeholder}
          styles={{
            "menu": (style) => {
              return { ...style, "z-index": 99 };
            }
          }} />
        {this.renderErrorArea()}
      </SelectContainer>
    );
  }
}

export default Select;