import React from "react";
import S2SBaseComponent from "s2s-base-class";
import ObjectMerge from "object-merge";
import PropTypes from "prop-types";
import { colorGrid } from "s2s-themes";
import { fromJS } from 'immutable';
import { AlertIconSVG, InfoIconSVG } from 's2s-svg-icons';
import styled from 'styled-components';
import * as svgIcons from 's2s-svg-icons';
import ToolTip from 's2s-tooltip';


const icons = { ...svgIcons };

// Parent container of everything in <Input />
const Container = styled.div`
    display : flex;
    flex-direction : column;
    position : relative;
    width : 100%;
`;

const Label = styled.label`
    color : inherit; // deriving color from parent <Information />
    display : flex;
    flex-direction : column;
    font-size : 14px;
    font-weight : 600;
    line-height : 14px;
    user-select : none;
    width : 100%;
`;

// Parent of {this.props.inputLabel} and <RelativeInfoIconContainer />
const Information = styled.div`
  display : flex;
  justify-content : space-between;
`;

const Hint = styled.div`
  color : ${colorGrid.gray5};
  font-weight : normal;
  line-height : 16px;
  margin-bottom : 8px;
  margin-top: 8px; 
  display: ${(props) => {

    return !props.hasHint ? 'none' : 'inherit';
  }}; 
  
`;

// Div containing InfoIconSVG - Exists to trigger mousover events and positioning tooltip based on <InfoIconSVG />.
const RelativeInfoIconContainer = styled.div`
    align-items : center;
    display : flex;
    justify-content : center;
    margin-left : auto;
    position : relative; // tool tip is gonna be relative to THIS container. K
    //width : 100%;
`;

// Parent div containing <ToolTip />, <LeftArrow />, and <BottomArrow />. Exists to position toolTip
// Tweaking positioning so that it is not rendering directly over <InfoIconSVG /> and handling toolTipLocation positioning.
const ToolTipContainer = styled.div`
    // styling necessary for positioning to <RelativeInfoIconContainer />
    position: absolute;
    left : ${(props) => props.toolTipLocation === "top" ? "-15px" : "20px"};
    top : ${(props) => props.toolTipLocation === "top" ? "-50px" : "-10px"};
    z-index : 20;
`;

// Actual tip area containing text
const InfoToolTip = styled.span`
    background-color : ${colorGrid.gray9};
    border-radius : 4px;
    color : ${colorGrid.gray0};
    font-size : 14px;
    height : 18px;
    line-height : 16px;
    min-width : 150px;
    position : absolute;
    padding : 8px;
    /* styling necessary for positioning to <ToolTipContainer /> */
    left : ${(props) => props.toolTipLocation === 'top' ? '-20px' : '0px'};
`;

// An empty div that renders the triangle to the left of <ToolTip />
const LeftArrow = styled.div`
    /* styling necessary to get triangle shape */
    width: 0; 
    height: 0; 
    border-top : 10px solid transparent;
    border-bottom : 10px solid transparent; 
    border-right : 10px solid ${colorGrid.gray9};

    /* styling necessary for positioning to <ToolTipContainer /> */
    position : absolute;
    left : -5px;
    top : 5px;
`;

// An empty div that renders the triangle underneath <ToolTip />
const BottomArrow = styled.div`
    /* styling necessary to get triangle shape */
    width: 0; 
    height: 0; 
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid ${colorGrid.gray9};
    cursor : pointer;

    /* styling necessary for positioning to <ToolTipContainer /> */
    position : absolute;
    left : 12px;
    top: 28px;
`;

//  Div containing SVG to the left of input
const InputTypeSVGArea = styled.div`
    align-items : center;
    background-color : ${props => {
      let backgroundColor = colorGrid.gray1;

      if (props.hasHover === true) {
        backgroundColor = colorGrid.gray3;
      }

      if (props.hasError === true && props.hasFocus == false) {
        backgroundColor = colorGrid.red6;
      }


      // We want SVG to change when INPUT has focus so cannot use pseudo classes here. - KCN 
      if (props.hasFocus === true) {
        backgroundColor = colorGrid.blue6;
      }

      return backgroundColor;
    }};
    border-radius : 4px;
    border-top-right-radius : ${props => props.hasSVG === true ? '0px' : '4px'};
    border-bottom-right-radius : ${props => props.hasSVG === true ? '0px' : '4px'};
    border-color : ${props => {
      let borderColor = colorGrid.gray3;

      if (props.hasError === true && props.hasFocus == false) {
        borderColor = colorGrid.red6;
      }

      // We want SVG to change when INPUT has focus so cannot use pseudo classes here. - KCN 
      if (props.hasFocus === true) {
        borderColor = colorGrid.blue6;
      }

      return borderColor;
    }};
    
    border-right-color : transparent;
    border-style : solid;
    border-width : 1px;
    display : flex;
    align-items: center;
    display : flex;
    flex-direction : row;
    justify-content : center;
    padding : 7px; /* Removed {flex : 1} property and adjusted this style adjusted so that height is 40px per LPAD-270. - KCN */
    position : relative;


    ${StyledInput}:hover {
      border-width : 2px;
    };

    ${StyledInput}:focus {
      border-width : 2px;
    };


`;

// This container exists so that PreviewIconSVG positioning does not change depending on if {inputLabel} is provided or not. 
const RelativeInputPreviewContainer = styled.div`
    align-items: center;
    display : flex;
    flex-direction : row;
    position : relative;
    margin-top: ${(props) => {
    let topMargin = '0px';

    if (props.hasLabel && !props.hasHint) {
      topMargin = '8px';
    }

    return topMargin;
  }}
`;

const StyledInput = styled.input`
    background-color : ${colorGrid.gray0};
    border-radius : 4px;
    border-top-left-radius : ${props => props.hasSVG === true ? '0px' : '4px'};
    border-bottom-left-radius : ${props => props.hasSVG === true ? '0px' : '4px'};
    border-color : ${props => {
    let borderColor = colorGrid.gray3;

    if (props.hasError === true && props.hasFocus == false) {
      borderColor = colorGrid.red6;
    }

    return borderColor;
    }};
    border-style : solid;
    border-width : 1px;
    box-sizing: border-box;
    font-size: 14px;
    height: 40px;
    outline : none;
    padding-left: 12px;
    width : 100%;
    &::placeholder {
        color : ${colorGrid.gray5}
    };

    &:hover {
      background-color : ${colorGrid.gray2};
      border-color : ${props => {
        let borderColor = colorGrid.gray5;

        if (props.hasError === true && props.hasFocus == false) {
          borderColor = colorGrid.red6;
        }

        return borderColor;
      }};

      border-width : 2px;
    };

    &:focus {
        border-color : ${colorGrid.blue6};
        border-width : 2px;
    };

    /* input does not have an acitve psuedo class (only <a> and <button> ) */
    &:active {
        //box-shadow : 0px;
    };
    &:disabled {
        border-color : ${colorGrid.gray2};
        cursor : not-allowed;
    };
`;

const AbsolutePreviewIconContainer = styled.div`
    /* styling necessary for positioning to <RelativeInputPreviewContainer /> */
    background-color : ${props => props.passwordShowing === true ? colorGrid.red1 : colorGrid.gray2};
    border-radius : 4px;
    display : ${props => props.inputType === 'password' ? 'block' : 'none'}; /* NOTE preventing from tabbing over PreviewIcon unless it is a password input-type - KCN */
    height : 32px;
    margin-right : 4px;
    outline : none;
    position : absolute;
    right : 0px;
    top : 4px;
    width : 32px;
    z-index : 2;

    
    &:hover {
      background-color : ${props => props.passwordShowing === true ? colorGrid.red3 : colorGrid.gray4}
    };

    :focus {
      /* box shadow exists on all s2s form elements is necessary to indicate active state and override default browser settings. Color value is a colorGrid value in rgba format with .6 opacity */
      -webkit-box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
      -moz-box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
      box-shadow: 0px 0px 0px 2px rgba(34,138,230,0.6);
    };
    
    :active {
      -webkit-box-shadow: none;
      -moz-box-shadow: none;
      box-shadow : none;
    };
`;

// Parent div of <ErrorSVGArea /> and <ErrorText />
const ErrorContainer = styled.div`
    align-items: center;
    background-color : ${colorGrid.red7};
    border-radius : 4px;
    box-shadow: 0px 4px 8px rgba(33, 37, 41, 0.4);
    color : ${colorGrid.gray0};
    display : flex;
    font-size : 14px;
    line-height : 16px;
    padding : 8px 12px;
    z-index : 3;

    /* styling necessary for positioning to <Container /> */
    position : absolute;
    top : ${(props) => {

    let topPosition = '55px'; // has neither hint or a label

    if (props.hasLabel && !props.hasHint) {
      topPosition = '61px';
    }

    if (props.hasHint && !props.hasLabel) {
      topPosition = '69px';
    }

    if (props.hasLabel && props.hasHint) {
      topPosition = '86px';
    }
    return topPosition;
  }}; 
    width : ${props => {
    let width = `calc(100% - 22px );`;  /* must account for padding left/right of <ErrorContainer />  and border of <StyledInput /> or it is not the full width */

    if (props.errorContainerWidth !== undefined) {
      width = props.errorContainerWidth;
    }
    return width;
  }};
      
      
`;

const PreviewPasswordToolTip = styled(ToolTip)`
  bottom : 42px;
  left : -42px;
  display : none;
  font-weight : normal;
 
  /* NOTE:  the '&' here is styled-component syntax that causes hovering over the AbsolutePreviewIconContainer to affect style of tooltip.  Reference
    advance section of styled-components documentation under 'Referring to other components' */
  ${AbsolutePreviewIconContainer}:hover & {
    display : flex;
    white-space : nowrap;
  };
`;

class Input extends S2SBaseComponent {
  constructor(props) {
    super(props);
    this.displayName = "Input";

    this.state = {
      isFocus: false,
      isHover: false,
      passwordShowing: false, // shows or hides text in a password input field
      toolTipDisplayed: false,
      previewPasswordHover: false
    };

    this.inputRef = React.createRef();

    this.handleTogglePreview = this.handleTogglePreview.bind(this);
    this.handleToolTipHoverIn = this.handleToolTipHoverIn.bind(this);
    this.handleToolTipHoverOut = this.handleToolTipHoverOut.bind(this);
    this.handleInputHoverIn = this.handleInputHoverIn.bind(this);
    this.handleInputHoverOut = this.handleInputHoverOut.bind(this);
    this.handleTogglePreviewKeyDown = this.handleTogglePreviewKeyDown.bind(this);
    this.handlePreviewPasswordHover = this.handlePreviewPasswordHover.bind(this);
    this.handleFocus = this.handleFocus.bind(this);
    this.handleBlur = this.handleBlur.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);

  }

  static propTypes = {
    autoFocus: PropTypes.bool,
    cbOnBlur: PropTypes.func,
    cbOnChange: PropTypes.func,
    cbOnEnter: PropTypes.func,
    cbOnFocus: PropTypes.func,
    cbOnIconClick: PropTypes.func,
    errorContainerWidth: PropTypes.string,
    errorText: PropTypes.string,
    hasError: PropTypes.bool,
    inputHint: PropTypes.string,
    inputLabel: PropTypes.string,
    inputType: PropTypes.oneOf(['email', 'password', 'text']),
    isDisabled: PropTypes.bool,
    placeholder: PropTypes.string,
    svgType: PropTypes.string,
    value: PropTypes.string,
    theme: PropTypes.object,
    toolTipLocation: PropTypes.oneOf(['top', 'right'])
  };

  static defaultProps = {
    autoFocus: false,
    cbOnEnter: () => { /*console.log('cbOnEnter is not defined');*/ },
    cbOnBlur: () => { /*console.log('cbOnBlur is not defined');*/ },
    cbOnChange: () => { /*console.log('cbOnChange is not defined');*/ },
    cbOnIconClick: () => { },
    cbOnFocus: () => { /*console.log('cbOnFocus is not defined');*/ },
    errorContainerWidth: undefined, // this prop was added due to issue in ApplicationVersions where the error message was extremely squished due to tiny input size. - KCN
    errorText: undefined,
    hasError: false,
    inputHint: undefined,
    inputLabel: undefined,
    inputType: 'text',
    isDisabled: false,
    placeholder: undefined,
    svgType: undefined,
    value: '',
    toolTipLocation: 'top'
  };

  static filename = 's2s-input';
  static displayName = 'Input';

  get value() {
    if (this.inputRef.current) {
      return this.inputRef.current.props.value; // NOTE : StyledInput is a styled component hence the odd return value. {this.inputRef.value} returns undefined! - KCN 05/02/2018
    } else {
      return undefined;
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !fromJS(nextProps).equals(fromJS(this.props)) || !fromJS(nextState).equals(fromJS(this.state));
  }

  // Renders a ToolTip popover
  renderToolTip() {
    let DynamicArrow = BottomArrow;
    if (this.props.toolTipLocation === 'right') {
      DynamicArrow = LeftArrow;
    }

    if (this.state.toolTipDisplayed === true) {
      return (
        <ToolTipContainer className="ToolTipContainer" toolTipLocation={this.props.toolTipLocation}>
          <InfoToolTip className="ToolTip" toolTipLocation={this.props.toolTipLocation}>
            {this.props.toolTipText}
          </InfoToolTip>
          <DynamicArrow className="DynamicArrow" />
        </ToolTipContainer>
      );
    }
  }

  // Render area containing 'info' icon and tooltip
  renderToolTipArea() {
    if (this.props.displayToolTip === true) {
      return (
        <RelativeInfoIconContainer
          className="RelativeInfoIconContainer"
          onMouseOver={this.handleToolTipHoverIn}
          onMouseOut={this.handleToolTipHoverOut}
        >
          <InfoIconSVG
            className="InfoIconSVG"
            onMouseOver={this.handleToolTipHoverIn}
            onMouseOut={this.handleToolTipHoverOut}
            svgStyle={{
              fill: this.state.toolTipDisplayed === true ? colorGrid.blue6 : 'currentColor', // if tooltip is active will display blue. Otherwise derives it inherits fill color from <Information /> color property.
              height: '12px',
              width: '12px'
            }}
          />
          {this.renderToolTip()}
        </RelativeInfoIconContainer>
      );
    }
  }

  renderSVGArea() {
    let displaySvg;

    if (this.props.svgType !== undefined && icons.hasOwnProperty(this.props.svgType)) {
      const DynamicSVG = icons[this.props.svgType];

      displaySvg = (
        <InputTypeSVGArea
          className="InputTypeSVGArea"
          hasError={this.props.hasError}
          hasFocus={this.state.isFocus}
          hasHover={this.state.isHover}
          hasSVG={this.props.svgType !== undefined ? true : false}
          onClick={this.props.cbOnIconClick}
        >
          <DynamicSVG
            className="DynamicSVG"
            svgStyle={{
              fill: (this.state.isFocus || this.props.hasError) === true ? colorGrid.gray0 : colorGrid.gray5,
              height: '24px',
              width: '24px'
            }}
          />
        </InputTypeSVGArea>
      );
    }

    return displaySvg;
  }

  renderPreviewIcon() {
    let DynamicPreviewIcon = icons['PreviewIconSVG'];
    if (this.state.passwordShowing === true) {
      DynamicPreviewIcon = icons['PreviewHiddenIconSVG'];
    }

    return (
      <DynamicPreviewIcon
        className="PreviewIconSVG"
        svgStyle={{
          alignItems: 'center',
          display: this.props.inputType === 'password' ? 'flex' : 'none',
          cursor: 'pointer',
          fill: this.state.previewPasswordHover === false ? colorGrid.gray5 : colorGrid.gray7,
          height: '24px',
          justifyContent: 'center',
          padding: '4px',
          width: '24px'
        }}
      />
    );
  }

  renderRelativeInputArea() {
    return (
      <RelativeInputPreviewContainer
        className="RelativeInputPreviewContainer"
        hasLabel={this.props.inputLabel !== undefined}
        hasHint={this.props.inputHint !== undefined}>
        {this.renderSVGArea()}
        <StyledInput
          autoComplete="off"
          autoFocus={this.props.hasError ? false : this.props.autoFocus} // Error is displayed on initial render, and cleared on focus. If we have an error, we do not want autoFocus on because then user will never see error message. - KCN 
          className="StyledInput"
          aria-label={this.props.ariaLabel}
          id={this.props.inputLabel}
          disabled={this.props.isDisabled}
          hasError={this.props.hasError}
          hasFocus={this.state.isFocus}
          hasSVG={this.props.svgType !== undefined ? true : false}
          onChange={this.handleChange}
          onFocus={this.handleFocus}
          onBlur={this.handleBlur}
          onKeyPress={this.handleKeyUp}
          onMouseEnter={this.handleInputHoverIn}
          onMouseLeave={this.handleInputHoverOut}
          type={this.state.passwordShowing === true ? 'text' : this.props.inputType}
          placeholder={this.props.placeholder}
          ref={this.inputRef}
          tabIndex={0}
          value={this.props.value}
        />
        <AbsolutePreviewIconContainer
          className="AbsolutePreviewIconContainer"
          onClick={this.handleTogglePreview}
          onMouseOver={this.handlePreviewPasswordHover}
          onMouseOut={this.handlePreviewPasswordHover}
          onKeyDown={this.handleTogglePreviewKeyDown}
          inputType={this.props.inputType}
          passwordShowing={this.state.passwordShowing}
          inputHasFocus
          tabIndex={0}
        >
          <PreviewPasswordToolTip label={this.state.passwordShowing ? "Hide Password" : "Show Password"} />
          {this.props.inputType === "password" ? this.renderPreviewIcon() : undefined}
        </AbsolutePreviewIconContainer>
      </RelativeInputPreviewContainer>

    );
  }

  // Renders Label and it's children including input
  getInputContainer() {
    return (
      <Label
        className="InputContainer"
        disabled={this.props.disabled}
        htmlFor={this.props.inputLabel} // ACCESSIBILITY YAS. Click this label...will focus cursor in input. - KCN
      >
        <Information className="Information" >
          {this.props.inputLabel}
          {this.renderToolTipArea()}
        </Information>
        <Hint
          hasHint={this.props.inputHint !== undefined}>
          {this.props.inputHint}
        </Hint>
        {this.renderRelativeInputArea()}

      </Label>
    );
  }

  // Render the error area
  renderErrorArea() {

    if (this.props.hasError === true && this.props.errorText !== undefined && this.state.isFocus === false) {
      return (
        <ErrorContainer
          className="ErrorContainer"
          errorContainerWidth={this.props.errorContainerWidth}
          hasLabel={this.props.inputLabel !== undefined}
          hasHint={this.props.inputHint !== undefined}
        >
          <div className="InputErrorSVGContainer">
            <AlertIconSVG
              className="AlertIconSVG"
              svgStyle={{
                fill: colorGrid.gray0,
                height: '24px',
                width: '24px',
                paddingRight: '12px'
              }}
            />
          </div>
          <span className="ErrorText">{this.props.errorText}</span>
        </ErrorContainer>
      );
    }
  }

  handlePreviewPasswordHover(/*e*/) {
    this.setState((prevState) => {
      return ObjectMerge({}, prevState, { 'previewPasswordHover': !this.state.previewPasswordHover });
    });
  }

  handleTogglePreview(e) {
    e.preventDefault();
    this.setState((prevState) => {
      return ObjectMerge({}, prevState, { 'passwordShowing': !this.state.passwordShowing });
    });
  }
  handleToolTipHoverIn() {
    this.setState((prevState) => {
      return ObjectMerge(prevState, { toolTipDisplayed: true });
    });
  }

  handleToolTipHoverOut() {
    this.setState(prevState => {
      return ObjectMerge({}, prevState, { toolTipDisplayed: false });
    });
  }

  handleInputHoverIn() {
    this.setState(prevState => {
      return ObjectMerge({}, prevState, { isHover: true });
    });
  }

  handleInputHoverOut() {
    this.setState(prevState => {
      return ObjectMerge({}, prevState, { isHover: false });
    });
  }

  handleFocus() {
    if (!this.props.isDisabled) {
      this.setState((prevState) => {
        return ObjectMerge(
          {},
          prevState,
          {
            'isFocus': true
          }
        );
      });
      this.props.cbOnFocus();
    }
  }

  handleBlur() {
    if (!this.props.isDisabled) {
      this.setState((prevState) => {
        return ObjectMerge({}, prevState, { 'isFocus': false });
      });
      this.props.cbOnBlur(this.props.value);
    }
  }

  handleChange(e) {

    //console.log('HANDLE CHANGE', e.target.value);

    let targetValue;
    // wrap in try catch so it will continue
    try {
      targetValue = decodeURI(encodeURI(e.target.value));
    } catch (e) {
      targetValue = e.target.value;
    }

    if (this.props.cbOnChange) {
      //console.log(e.target.value, e.nativeevent, e);
      this.props.cbOnChange(targetValue);
    }
  }

  handleKeyUp(e) {
    if (e.charCode == 13) {
      this.props.cbOnEnter(this.props.value);
    }
    return true;
  }

  handleTogglePreviewKeyDown(event) {
    if (event.keyCode === 13) {
      this.handleTogglePreview(event);
    }
  }

  render() {

    return (
      <Container
        className={this.props.className}>
        {this.getInputContainer()}
        {this.renderErrorArea()}
      </Container>
    );
  }
}

export default Input;
// BY KC Nichols - 06/26/2018
