import React from 'react';
import ViewHeader from '../src/viewHeader.js';
import { shallow, mount } from 'enzyme';
import sinon from 'sinon';
jest.unmock('../src/viewHeader.js');
jest.unmock('../node_modules/immutable');

describe('ViewHeader Component', ()=>{
  it('rerenders when props have changed', () => {
    const spy = sinon.spy(ViewHeader.prototype, "render");

    const wrapper = shallow(<ViewHeader headerData="What is Time" />);

    // render is always called once so before setting any props check that it was called once.
    expect(spy.calledOnce).toEqual(true);

    // After setting props check to see if render has been called twice (initial render and render after props have changed)
    wrapper.setProps({ headerData : "Time is a social construct" });
    expect(spy.calledTwice).toEqual(true);

    // Now checking to see if render is called again even though props are the same. Should be false.
    wrapper.setProps({ headerData : "Time is a social construct" });
    expect(spy.calledThrice).toEqual(false);
  });

  it('fires a cbHeaderClick', () => {
    const spy1 = sinon.spy();
    const wrapper = mount(
      <ViewHeader
          dateVal='Date Value'
          cbHeaderClick={spy1}
      />);

    //console.log('wrapper', wrapper.debug());
    wrapper.childAt(0).simulate('click');
    expect(spy1.calledOnce).toEqual(true);

    wrapper.childAt(1).simulate('click');
    expect(spy1.calledTwice).toEqual(true);

    wrapper.childAt(2).simulate('click');
    expect(spy1.calledThrice).toEqual(true);
  });

  it('fires a navTitleCbClick', () => {
    const spy1 = sinon.spy();
    const spy2 = sinon.spy(ViewHeader.prototype, 'navTitleCbClick');
    const wrapper = mount(
      <ViewHeader
          dateVal='Date Value'
          cbHeaderClick={spy1}
      />);

    wrapper.childAt(1).simulate('click');
    expect(spy2.calledOnce).toEqual(true);
  });

  it('fires a nextCbClick', () => {
    const spy1 = sinon.spy();
    const spy2 = sinon.spy(ViewHeader.prototype, 'nextCbClick');
    const wrapper = mount(
      <ViewHeader
          dateVal='Date Value'
          cbHeaderClick={spy1}
      />);

    wrapper.childAt(2).simulate('click');
    expect(spy2.calledOnce).toEqual(true);
  });

  it('fires a previousCbClick', () => {
    const spy1 = sinon.spy();
    const spy2 = sinon.spy(ViewHeader.prototype, 'previousCbClick');
    const wrapper = mount(
      <ViewHeader
          dateVal='Date Value'
          cbHeaderClick={spy1}
      />);

    wrapper.childAt(0).simulate('click');
    expect(spy2.calledOnce).toEqual(true);
  });
});
