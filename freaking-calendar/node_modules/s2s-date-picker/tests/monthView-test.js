import React from 'react';
import MonthView from '../src/monthView.js';
import { shallow, mount } from 'enzyme';
import sinon from 'sinon';
import moment from 'moment';
import range from 'moment-range';
jest.unmock('../node_modules/moment-range');
jest.unmock('../node_modules/moment');
jest.unmock('../src/monthView.js');


/*
  cbNextView: React.PropTypes.func,
  cbSetDate: React.PropTypes.func,
  dateVal: React.PropTypes.object.isRequired,
  maxDate: React.PropTypes.object,
  minDate: React.PropTypes.object
*/
describe('MonthView Component', ()=>{
  //var newDate = new Date("July 25, 1990 09:05:00").getTimestamp();
  var ddate1 = moment(648915551);
  var ddate2 = moment(Date.now());
  //console.log('formatteddate', formattedDate);

  it('rerenders when props have changed', () => {
    const spy = sinon.spy(MonthView.prototype, "render");

    const wrapper = shallow(
      <MonthView
          dateVal={ddate1}
      />);

    // render is always called once so before setting any props check that it was called once.
    expect(spy.calledOnce).toEqual(true);

    // After setting props check to see if render has been called twice (initial render and render after props have changed)
    wrapper.setProps({ dateVal: ddate2 });
    expect(spy.calledTwice).toEqual(true);

    // Now checking to see if render is called again even though props are the same. Should be false.
    wrapper.setProps({ dateVal: ddate2 });
    expect(spy.calledThrice).toEqual(false);
  });

  it('renders date value', () => {
    const wrapper = mount(
      <MonthView
          dateVal={ddate1}
      />);

    expect(wrapper.find('ViewHeader').childAt(1).find('span').text()).toEqual('1970');
  });

  it('fires cellClick function on click', () => {
    const spy1 = sinon.spy(MonthView.prototype, 'cellClick');
    const wrapper = mount(
      <MonthView
          dateVal={ddate1}
      />);

    wrapper.childAt(1).simulate('click');
    expect(spy1.calledOnce).toEqual(true);
  });

  it('fires cellClick function on keypress', () => {
    const spy1 = sinon.spy(MonthView.prototype, 'monthsOnKeyPress');
    const wrapper = mount(
      <MonthView
          cbPrevView={spy1}
          dateVal={ddate1}
      />);

    wrapper.childAt(1).simulate('keypress');
    expect(spy1.calledOnce).toEqual(true);
  });

  it('fires prev function', () => {
    const spy1 = sinon.spy(MonthView.prototype, 'prev');
    const spy2 = sinon.spy();
    const wrapper = mount(
      <MonthView
          dateVal={ddate1}
          cbSetDate={spy2}
      />);

    //console.log('wrapper', wrapper.childAt(0).childAt(0).debug());
    wrapper.childAt(0).childAt(0).simulate('click');
    expect(spy1.calledOnce).toEqual(true);
    expect(spy2.calledOnce).toEqual(true);
  });

  it('fires handleTitleClick function', () => {
    const spy2 = sinon.spy(MonthView.prototype, 'handleTitleClick');
    const spy1 = sinon.spy();
    const wrapper = mount(
      <MonthView
          dateVal={ddate1}
          //cbSetDate={spy1}
          cbNextView={spy1}
      />);

    //console.log('wrapper', wrapper.childAt(0).childAt(0).debug());
    wrapper.childAt(0).childAt(1).simulate('click');
    //console.log('calllcount', spy3.callCount)
    expect(spy1.calledOnce).toEqual(true);
    expect(spy2.calledOnce).toEqual(true);
  });

  it('fires next function', () => {
    const spy1 = sinon.spy();
    const spy2 = sinon.spy(MonthView.prototype, 'next');
    const wrapper = mount(
      <MonthView
          dateVal={ddate1}
          cbSetDate={spy1}
          cbNextView={spy1}
      />);

    wrapper.childAt(0).childAt(2).simulate('click');
    expect(spy1.calledOnce).toEqual(true);
    expect(spy2.calledOnce).toEqual(true);
  });

});
