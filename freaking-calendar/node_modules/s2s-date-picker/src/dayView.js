import React from 'react';
import S2SBaseComponent from 's2s-base-class';
import Cell from './cell';
import cs from 'classnames';
import ViewHeader from './viewHeader';
import moment from 'moment';
import { fromJS } from 'immutable';
import defaultComponentStyle from "./styles.js";
// Day View is a normal calendar.

class DayView extends S2SBaseComponent {
  constructor(props){
      super(props);
      this.displayName = 'DayView';
      this.state = {
        'selectedDate': false
      };

      this.moment = moment();
      this.prev = this.prev.bind(this);
      this.next = this.next.bind(this);
      this.cellClick = this.cellClick.bind(this);
      this.daysOnKeyPress = this.daysOnKeyPress.bind(this);
      this.handleTitleClick = this.handleTitleClick.bind(this);
      this.currentDate = this.props.dateVal ? this.props.dateVal.format('MMMM YYYY') : this.moment.format('MMMM YYYY');

      this.prefetchStyles();
  }

  static propTypes = {
    cbNextView: React.PropTypes.func,
    cbSetDate: React.PropTypes.func,
    dateVal: React.PropTypes.object.isRequired,
    maxDate: React.PropTypes.object,
    minDate: React.PropTypes.object
  };

  static defaultProps = {
    cbNextView : undefined,
    cbSetDate : undefined,
    dateVal : {},
    minDate : moment().add(-10000, 'days'),
    maxDate : moment().add(10000, 'days')
  };

  componentWillReceiveProps(nextProps) {
    if (nextProps.hasOwnProperty('dateVal')) {
      this.currentDate = nextProps.dateVal ? nextProps.dateVal.format('MMMM YYYY') : this.moment.format('MMMM YYYY');
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !fromJS(nextProps).equals(fromJS(this.props)) || !fromJS(nextState).equals(fromJS(this.state));
  }

  getDefaultStyle(styleName, objectPropState)  {
    return defaultComponentStyle(styleName, objectPropState);
  }

  cellClick(e) {
    let cell = e.target;
    let date = parseInt(cell.innerHTML, 10);
    let newDate = this.props.dateVal ? this.props.dateVal.clone() : this.moment;

    if (isNaN(date)) return;

    if (cell.className.indexOf('prev') > -1 ) {
      newDate.subtract(1, 'months');
    } else if (cell.className.indexOf('next') > -1) {
      newDate.add(1, 'months');
    }

    newDate.date(date);
    this.props.cbSetDate(newDate, true);

  }

  getDays() {
    const now = this.props.dateVal ? this.props.dateVal : this.moment;
    const start = now.clone().startOf('month').weekday(0);
    const end = now.clone().endOf('month').weekday(6);
    const minDate = this.props.minDate;
    const maxDate = this.props.maxDate;
    const month = now.month();
    const today = this.moment;
    const currDay = now.date();
    const year = now.year();
    const days = [];

    this.moment
      .range(start, end)
      .by('days', day => {
        days.push({
          label: day.format('D'),
          prev: (day.month() < month && !(day.year() > year)) || day.year() < year ,
          next: day.month() > month || day.year() > year,
          disabled: day.isBefore(minDate, 'day') || day.isAfter(maxDate, 'day'),
          curr: day.date() === currDay && day.month() === month,
          today: day.date() === today.date() && day.month() === today.month() && day.year() === today.year()
        });
      });
    return days;
  }

  next(){
    let nextDate = this.props.dateVal.clone().add(1, 'months');
    if (this.props.maxDate && nextDate.isAfter(this.props.maxDate, 'day')) {
      nextDate = this.props.maxDate;
    }
    this.props.cbSetDate(nextDate);
  }

  prev(){
    let prevDate = this.props.dateVal.clone().subtract(1, 'months');
    if (this.props.minDate && prevDate.isBefore(this.props.minDate, 'day')) {
      prevDate = this.props.minDate;
    }
    this.props.cbSetDate(prevDate);
  }

  handleTitleClick(type){
    switch(type) {
      case 'previous':
        this.prev();
        break;
      case 'title':
        this.props.cbNextView();
        break;
      case 'next':
        this.next();
        break;
    }
  }

  daysOnKeyPress(e){
    if(e.charCode == '13') {
      this.cellClick(e);
    }
  }

  prefetchStyles(){
    this.daysView = this.getStyle('daysView');
    this.lonerDays = this.getStyle('lonerDays');
    this.viewHeaderDayView = this.getStyle('viewHeaderDayView');
    this.daysWrapper = this.getStyle('daysWrapper');
  }

  render(){

    let days = this.getDays().map((item, i) => {
      let _class;

      _class = cs({
        day: true,
        next: item.next,
        prev: item.prev,
        current: item.curr,
        today: item.today
      });

      let style;
      if(_class.indexOf('prev') > -1 || _class.indexOf('next') > -1) {
        style = ({ cellWrapper : {...this.lonerDays }});
      } else {
        style = undefined;
      }

      return (
        <Cell
            classes={_class}
            key={i}
            isSelected={_class.indexOf('current') > -1}
            compStyle={style}
            dateVal={item.label}
        />
        );
    });

    return(
      <div
          className="view days-view"
          style={this.daysView}
      >
          <ViewHeader
              key="ViewHeader - Day"
              headerData={this.currentDate}
              cbHeaderClick={this.handleTitleClick}
              compStyle={this.viewHeaderDayView}
          />
          <div
              className="days"
              tabIndex={0}
              onClick={this.cellClick}
              role="button"
              style={this.daysWrapper}
              onKeyDown={this.daysOnKeyPress}
          >
              {days}
          </div>
     </div>
    );
  }
}

export default DayView;
