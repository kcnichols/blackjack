import React from 'react';
import S2SBaseComponent from 's2s-base-class';
import { fromJS } from 'immutable';
import moment from 'moment';
import 'moment-range';
import DayView from './dayView';
import MonthView from './monthView';
import YearView from './yearView';
import defaultComponentStyle from "./styles.js";


class Calendar extends S2SBaseComponent {
  constructor(props, context) {
    super(props, context);
    this.displayName = 'Calendar';

    this.state = {
       timestamp: this.props.timestamp,
       currentView: 0 // days view should be by default
    };

    // this.cellClick = this.cellClick.bind(this); // NOTE: This is not being invoked anywhere so this is commented out unless an issue should arise. - KCN
    this.checkIfDateDisabled = this.checkIfDateDisabled.bind(this);
    this.nextView = this.nextView.bind(this);
    this.prevView = this.prevView.bind(this);
    this.setDate = this.setDate.bind(this);

    this.prefetchStyles();
  }

  static propTypes = {
    cbChange: React.PropTypes.func, // TODO : What is the difference between the two?
    cbSetDate: React.PropTypes.func,
    compStyle : React.PropTypes.object,
    disabled: React.PropTypes.bool,
    isDisplayed : React.PropTypes.bool,
    maxDate: React.PropTypes.object, // moment object
    minDate: React.PropTypes.object, // moment object
    timestamp: React.PropTypes.number
  };

  static defaultProps = {
    cbChange : ()=>{ console.log('Please provide a callback function for cbChange in calendar.js'); },
    cbSetDate : ()=>{ console.log('Please provide a callback function for cbSetDate in calendar.js'); },
    disabled : false,
    // minDate/maxDate by default is a crazy amount.
    minDate : moment().add(-10000, 'days'),
    maxDate : moment().add(10000, 'days'),
    timestamp: Date.now()
  };

  componentWillReceiveProps(nextProps){
    this.setState({...this.state, timestamp: nextProps.timestamp });
  }

  shouldComponentUpdate(nextProps, nextState) {
    //console.log('state', this.state, nextState)
    return !fromJS(nextProps).equals(fromJS(this.props)) || !fromJS(nextState).equals(fromJS(this.state));
  }

  getDefaultStyle(styleName, objectPropState)  {
    return defaultComponentStyle(styleName, objectPropState);
  }

  // cellClick(e) {
  //   let cell = e.target;
  //   let date = parseInt(cell.innerHTML, 10);
  //   let newDate = this.state.timestamp ? this.state.timestamp.clone() : moment();
  //
  //   if (isNaN(date)) return;
  //
  //   // this allows < or > to show the previous or next month
  //   if (cell.className.indexOf('prev') > -1 ) {
  //     newDate.subtract(1, 'months');
  //   } else if (cell.className.indexOf('next') > -1) {
  //     newDate.add(1, 'months');
  //   }
  //
  //   newDate.date(date);
  //   this.props.cbSetDate(newDate, true);
  // }

  checkIfDateDisabled(date) {
    return date !== undefined && this.props.minDate !== undefined && date.isBefore(this.props.minDate, 'day')
      || date && this.props.maxDate && date.isAfter(this.props.maxDate, 'day');
  }

  nextView() {
    //if (this.checkIfDateDisabled(this.state.timestamp)) return;
    this.setState({...this.state, currentView: this.state.currentView + 1 });
  }

  prevView(date) {
    //console.log(date)
    let newDate = date;
    if (this.props.minDate && date.isBefore(this.props.minDate, 'day')) {
      newDate = this.props.minDate.clone();
    }

    if (this.props.maxDate && date.isAfter(this.props.maxDate, 'day')) {
      newDate = this.props.maxDate.clone();
    }

    this.setState({ ...this.state, timestamp: date.valueOf(), currentView: --this.state.currentView });

    if (this.state.currentView === this.state.minView) { // TODO: No such thing need to remove this.state.minView without ruining logic
      this.setState({ ...this.state, timestamp: newDate.valueOf() });
    } else {
      this.setState({ ...this.state, timestamp: date.valueOf(), currentView: this.state.currentView - 1 });
    }
  }

  setDate(date, isDayView = false) {
    if (this.checkIfDateDisabled(date)) return;
    this.setState({ ...this.state, timestamp: date.valueOf() });

    if (this.props.cbChange || this.props.cbSetDate) {
      this.props.cbChange(date.valueOf());
    }
  }

  prefetchStyles(){
    this.todayWrapper = this.getStyle('todayWrapper');
    this.calendarWrapper = this.getStyle("calendarWrapper");
  }

  render() {
    // its ok for this.state.date to be null, but we should never
    // pass null for the date into the calendar pop up, as we want
    // it to just start on todays date if there is no date set
    let calendarDate = moment(this.state.timestamp).isValid()?  moment(this.state.timestamp) : moment();

    let view;
    switch (this.state.currentView) {
      case 0:
        view = (
          <DayView
              dateVal={calendarDate}
              cbNextView={this.nextView}
              maxDate={this.props.maxDate}
              minDate={this.props.minDate}
              cbSetDate={this.setDate}
        />);
        break;
      case 1:
        view = (
          <MonthView
              dateVal={calendarDate}
              cbNextView={this.nextView}
              maxDate={this.props.maxDate}
              minDate={this.props.minDate}
              cbPrevView={this.prevView}
              cbSetDate={this.setDate}
        />);
        break;
      case 2:
        view = (
          <YearView
              dateVal={calendarDate}
              maxDate={this.props.maxDate}
              minDate={this.props.minDate}
              cbPrevView={this.prevView}
              cbSetDate={this.setDate}
          />);
        break;
      default:
        view = (
          <DayView
              //cbInputChange={()=>{ console.log('define a callback function in calendarjs!!!')}}
              dateVal={calendarDate}
              cbNextView={this.nextView}
              maxDate={this.props.maxDate}
              minDate={this.props.minDate}
              cbSetDate={this.setDate}
          />);
    }

    let calendar = !this.props.isDisplayed || this.props.disabled ? '' :
      (<div
          style={this.todayWrapper}
      >
        {view}
      </div>);

    return (
      <div
          className="input-calendar"
          style={this.calendarWrapper}
      >
          {calendar}
      </div>
    );
  }
}

export default Calendar;
