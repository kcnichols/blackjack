'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _s2sBaseClass = require('s2s-base-class');

var _s2sBaseClass2 = _interopRequireDefault(_s2sBaseClass);

var _immutable = require('immutable');

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

require('moment-range');

var _dayView = require('./dayView');

var _dayView2 = _interopRequireDefault(_dayView);

var _monthView = require('./monthView');

var _monthView2 = _interopRequireDefault(_monthView);

var _yearView = require('./yearView');

var _yearView2 = _interopRequireDefault(_yearView);

var _styles = require('./styles.js');

var _styles2 = _interopRequireDefault(_styles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Calendar = function (_S2SBaseComponent) {
  _inherits(Calendar, _S2SBaseComponent);

  function Calendar(props, context) {
    _classCallCheck(this, Calendar);

    var _this = _possibleConstructorReturn(this, (Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call(this, props, context));

    _this.displayName = 'Calendar';

    _this.state = {
      timestamp: _this.props.timestamp,
      currentView: 0 // days view should be by default
    };

    // this.cellClick = this.cellClick.bind(this); // NOTE: This is not being invoked anywhere so this is commented out unless an issue should arise. - KCN
    _this.checkIfDateDisabled = _this.checkIfDateDisabled.bind(_this);
    _this.nextView = _this.nextView.bind(_this);
    _this.prevView = _this.prevView.bind(_this);
    _this.setDate = _this.setDate.bind(_this);

    _this.prefetchStyles();
    return _this;
  }

  _createClass(Calendar, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      this.setState(_extends({}, this.state, { timestamp: nextProps.timestamp }));
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps, nextState) {
      //console.log('state', this.state, nextState)
      return !(0, _immutable.fromJS)(nextProps).equals((0, _immutable.fromJS)(this.props)) || !(0, _immutable.fromJS)(nextState).equals((0, _immutable.fromJS)(this.state));
    }
  }, {
    key: 'getDefaultStyle',
    value: function getDefaultStyle(styleName, objectPropState) {
      return (0, _styles2.default)(styleName, objectPropState);
    }

    // cellClick(e) {
    //   let cell = e.target;
    //   let date = parseInt(cell.innerHTML, 10);
    //   let newDate = this.state.timestamp ? this.state.timestamp.clone() : moment();
    //
    //   if (isNaN(date)) return;
    //
    //   // this allows < or > to show the previous or next month
    //   if (cell.className.indexOf('prev') > -1 ) {
    //     newDate.subtract(1, 'months');
    //   } else if (cell.className.indexOf('next') > -1) {
    //     newDate.add(1, 'months');
    //   }
    //
    //   newDate.date(date);
    //   this.props.cbSetDate(newDate, true);
    // }

  }, {
    key: 'checkIfDateDisabled',
    value: function checkIfDateDisabled(date) {
      return date !== undefined && this.props.minDate !== undefined && date.isBefore(this.props.minDate, 'day') || date && this.props.maxDate && date.isAfter(this.props.maxDate, 'day');
    }
  }, {
    key: 'nextView',
    value: function nextView() {
      //if (this.checkIfDateDisabled(this.state.timestamp)) return;
      this.setState(_extends({}, this.state, { currentView: this.state.currentView + 1 }));
    }
  }, {
    key: 'prevView',
    value: function prevView(date) {
      //console.log(date)
      var newDate = date;
      if (this.props.minDate && date.isBefore(this.props.minDate, 'day')) {
        newDate = this.props.minDate.clone();
      }

      if (this.props.maxDate && date.isAfter(this.props.maxDate, 'day')) {
        newDate = this.props.maxDate.clone();
      }

      this.setState(_extends({}, this.state, { timestamp: date.valueOf(), currentView: --this.state.currentView }));

      if (this.state.currentView === this.state.minView) {
        // TODO: No such thing need to remove this.state.minView without ruining logic
        this.setState(_extends({}, this.state, { timestamp: newDate.valueOf() }));
      } else {
        this.setState(_extends({}, this.state, { timestamp: date.valueOf(), currentView: this.state.currentView - 1 }));
      }
    }
  }, {
    key: 'setDate',
    value: function setDate(date) {
      var isDayView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this.checkIfDateDisabled(date)) return;
      this.setState(_extends({}, this.state, { timestamp: date.valueOf() }));

      if (this.props.cbChange || this.props.cbSetDate) {
        this.props.cbChange(date.valueOf());
      }
    }
  }, {
    key: 'prefetchStyles',
    value: function prefetchStyles() {
      this.todayWrapper = this.getStyle('todayWrapper');
      this.calendarWrapper = this.getStyle("calendarWrapper");
    }
  }, {
    key: 'render',
    value: function render() {
      // its ok for this.state.date to be null, but we should never
      // pass null for the date into the calendar pop up, as we want
      // it to just start on todays date if there is no date set
      var calendarDate = (0, _moment2.default)(this.state.timestamp).isValid() ? (0, _moment2.default)(this.state.timestamp) : (0, _moment2.default)();

      var view = void 0;
      switch (this.state.currentView) {
        case 0:
          view = _react2.default.createElement(_dayView2.default
          //cbInputChange={()=>{ console.log('define a callback function in calendarjs!!!')}}
          , {
            dateVal: calendarDate,
            cbNextView: this.nextView,
            maxDate: this.props.maxDate,
            minDate: this.props.minDate,
            cbSetDate: this.setDate
          });
          break;
        case 1:
          view = _react2.default.createElement(_monthView2.default, {
            dateVal: calendarDate,
            cbNextView: this.nextView,
            maxDate: this.props.maxDate,
            minDate: this.props.minDate,
            cbPrevView: this.prevView,
            cbSetDate: this.setDate
          });
          break;
        case 2:
          view = _react2.default.createElement(_yearView2.default, {
            dateVal: calendarDate,
            maxDate: this.props.maxDate,
            minDate: this.props.minDate,
            cbPrevView: this.prevView,
            cbSetDate: this.setDate
          });
          break;
        default:
          view = _react2.default.createElement(_dayView2.default, { dateVal: calendarDate,
            cbNextView: this.nextView,
            maxDate: this.props.maxDate,
            minDate: this.props.minDate,
            cbSetDate: this.setDate
          });
      }

      var calendar = !this.props.isDisplayed || this.props.disabled ? '' : _react2.default.createElement(
        'div',
        {
          style: this.todayWrapper
        },
        view
      );

      return _react2.default.createElement(
        'div',
        {
          className: 'input-calendar',
          style: this.calendarWrapper
        },
        calendar
      );
    }
  }]);

  return Calendar;
}(_s2sBaseClass2.default);

Calendar.propTypes = {
  cbChange: _react2.default.PropTypes.func, // TODO : What is the difference between the two?
  cbSetDate: _react2.default.PropTypes.func,
  compStyle: _react2.default.PropTypes.object,
  disabled: _react2.default.PropTypes.bool,
  isDisplayed: _react2.default.PropTypes.bool,
  maxDate: _react2.default.PropTypes.object, // moment object
  minDate: _react2.default.PropTypes.object, // moment object
  timestamp: _react2.default.PropTypes.number
};
Calendar.defaultProps = {
  cbChange: function cbChange() {
    console.log('Please provide a callback function for cbChange in calendar.js');
  },
  cbSetDate: function cbSetDate() {
    console.log('Please provide a callback function for cbSetDate in calendar.js');
  },
  disabled: false,
  // minDate/maxDate by default is a crazy amount.
  minDate: (0, _moment2.default)().add(-10000, 'days'),
  maxDate: (0, _moment2.default)().add(10000, 'days'),
  timestamp: Date.now()
};
exports.default = Calendar;
