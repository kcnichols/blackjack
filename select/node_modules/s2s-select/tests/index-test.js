import React from 'react';
import { shallow, mount, render } from 'enzyme';
import sinon from 'sinon';
jest.unmock('../src/index.js');
jest.unmock('../node_modules/s2s-svg-icons');
import Select from '../src/index.js';

describe('Select Component', ()=>{

  const hockeyTeams = [
    'Tampa Bay Lightning',
    'Toronto Maple Leafs',
    'Montreal Canadiens',
    'Detroit Red Wings',
    'New York Rangers',
    'Boston Bruins',
    'Chicago Blackhawks',
    'Pittsburg Penguins',
    'Minnesota Wild',
    'San Jose Sharks',
    'Los Angeles Kings',
    'Vancouver Canucks',
    'New York Islanders',
    'Carolina Hurricans',
    'Florida Panthers',
    'Dallas Stars',
    'Nashville Predators',
    'Edmonton Oilers',
    'Calgary Flames',
    'Philadelphia Flyers',
    'Winnipeg Jets',
    'Columbus Blue Jackets',
    'Buffalo Sabres',
    'New Jersey Devils',
    'Anaheim Ducks',
    'Arizona Coyotes',
    'St Louis Blues',
    'Washington Capitals',
    'Ottawa Senators'
  ];

  const goalies = [
    'Ben Bishop',
    'Peter Budaj',
    'Carey Price',
    'Andre Vasilevisky'
  ];

  it('rerenders when props have changed', () => {
    const spy = sinon.spy(Select.prototype, "render");

    const wrapper = shallow(<Select data={hockeyTeams} />);

    // render is always called once so before setting any props check that it was called once.
    expect(spy.calledOnce).toEqual(true);

    // After setting props check to see if render has been called twice (initial render and render after props have changed)
    wrapper.setProps({ data: goalies });
    expect(spy.calledTwice).toEqual(true);

    // Now checking to see if render is called again even though props are the same. Should be false.
    wrapper.setProps({ data: goalies});
    expect(spy.calledThrice).toEqual(false);
  });

  it('renders a default item provided', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          data={hockeyTeams}
          defaultSelectedItem={9}
      />);

    expect(wrapper.find('.defaultSelectedItem').text()).toEqual("San Jose Sharks");
  });

  it('renders a list of items', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          data={hockeyTeams}
      />);

    expect(wrapper.find('.displayItems').children().length).toEqual(29);
  });
  it('renders error', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          data={hockeyTeams}
          hasError
      />);

    expect(wrapper.find('.errorArea').length).toEqual(1);
  });

  it('does NOT render error', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          data={hockeyTeams}
          hasError={false}
      />);

    expect(wrapper.find('.errorArea').length).toEqual(0);
  });

  it('renders custom error message', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          hasError
          data={hockeyTeams}
          errorText="Sidney Crosby is NOT your favorite player."
      />);

    expect(wrapper.find('.errorText').text()).toEqual("Sidney Crosby is NOT your favorite player.");
  });

  // TODO: TypeError: Cannot read property 'equals' of undefined
  it('dropdown is visible', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          hasError
          data={hockeyTeams}
          errorText="Sidney Crosby is NOT your favorite player."
          itemsVisible={3}
      />);
    const wrapperOpen = wrapper.setState({ isOpen: true, hasError: false });
    expect(wrapperOpen.find('.displayItems').props().style.visibility).toEqual('visible');
  });
  //TODO: TypeError: Cannot read property 'equals' of undefined
  it('dropdown is NOT visible', () => {
    const wrapper = shallow(
      <Select
          customLabel = "Favorite Hockey Team"
          customHint ="Please select your favorite hockey team."
          hasError
          data={hockeyTeams}
          errorText="Sidney Crosby is NOT your favorite player."
          itemsVisible={3}
      />);
    const wrapperClosed = wrapper.setState({ isOpen: false, hasError: false });
    expect(wrapperClosed.find('.displayItems').props().style.visibility).toEqual('hidden');
  });

  // // TESTING CLASS METHODS SECTION

  it('toggleSelect fired', () => {
    // NOTE: sinon.spy() will only work if the cb function is doing is ONLY calling the prop. Since callback function is also setting state must define an argument with the appropriate object and the function that fires.
    const clock = sinon.useFakeTimers();
    const spy = sinon.spy(Select.prototype, 'toggleSelect');
    const spy2 = sinon.spy();

    const wrapper = shallow(
      <Select
          data={hockeyTeams}
          cbOnClick={spy2}
      />
    );

    wrapper.find('.dropDownMenu').simulate('mousedown'); // TODO : Test cbOnClick fire not true due to timeout
    clock.tick(0); // NOTE: since cbOnClick is wrapped in a timeout I need to make time pass after mousedown simulation
    expect(spy.calledOnce).toEqual(true); // testing toggleSelect
    expect(spy2.calledOnce).toEqual(true); // testing cbOnClick
    expect(Select.prototype.toggleSelect.calledOnce).toEqual(true);
    expect(wrapper.state().isOpen).toEqual(true); // testing state change

    wrapper.find('.dropDownMenu').simulate('mousedown'); // TODO : Test cbOnClick fire not true due to timeout
    clock.tick(0); // NOTE: since cbOnClick is wrapped in a timeout I need to make time pass after mousedown simulation
    expect(spy.calledTwice).toEqual(true); // testing toggleSelect
    expect(spy2.calledTwice).toEqual(true); // testing cbOnClick
    expect(wrapper.state().isOpen).toEqual(false); // testing state change
    expect(Select.prototype.toggleSelect.calledTwice).toEqual(true);

  });

  it('selectItem fired', () => {
    const spy = sinon.spy(Select.prototype, 'selectItem');
    const spy2 = sinon.spy();
    const wrapper = shallow(
      <Select
          customLabel="Favorite Hockey Team"
          customHint="Please select your favorite hockey team."
          data={hockeyTeams}
          cbValueChanged={spy2}
      />);
    wrapper.find('.option-0').simulate('mousedown');

    expect(spy.calledOnce).toEqual(true);
    expect(Select.prototype.selectItem.calledOnce).toEqual(true);
    expect(spy2.calledOnce).toEqual(true);
  });

  it('onBlurToggle fired', () => {
    const spy = sinon.spy(Select.prototype, 'onBlurToggle');
    const wrapper = shallow(
      <Select
          data={hockeyTeams}
      />);

    wrapper.find('.wrapper').simulate('blur');
    expect(spy.calledOnce).toEqual(true);
    expect(wrapper.state().isOpen).toEqual(false);
  });

  //TODO: Get argument passed in somehow
  // it('onItemHover fired', () => {
  //   const spy = sinon.spy(Select.prototype, 'onItemHover');
  //   const spy2 = sinon.spy().withArgs('Tampa Bay Lightning')
  //   const wrapper = shallow(
  //     <Select
  //         customLabel="Favorite Hockey Team"
  //         customHint="Please select your favorite hockey team."
  //         data={hockeyTeams}
  //         cbValueChanged={spy2}
  //     />);
  //
  //   //spy.withArgs('Tampa Bay Lightning'); // NOTE: This is not working due to conditional statement that changes backgroundColor.
  //   wrapper.find('.option-0').simulate('mouseover');
  //
  //   expect(wrapper.state().itemHovered).toEqual(undefined);
  // });

  it('handleMouseEnter fired', () => {
    const spy = sinon.spy(Select.prototype, 'handleMouseEnter');
    const wrapper = shallow(
      <Select
          customLabel="Favorite Hockey Team"
          customHint="Please select your favorite hockey team."
          data={hockeyTeams}
      />);
    wrapper.find('.selectArea').simulate('mouseenter');

    expect(spy.calledOnce).toEqual(true);
    expect(Select.prototype.handleMouseEnter.calledOnce).toEqual(true);
    expect(wrapper.state().hover).toEqual(true);
  });

  it('onMouseOut fired', () => {
    const spy = sinon.spy(Select.prototype, 'onMouseOut');
    const wrapper = shallow(
      <Select
          customLabel="Favorite Hockey Team"
          customHint="Please select your favorite hockey team."
          data={hockeyTeams}
      />);
    wrapper.find('.selectArea').simulate('mouseleave');

    expect(spy.calledOnce).toEqual(true);
    expect(Select.prototype.onMouseOut.calledOnce).toEqual(true);
    expect(wrapper.state().hover).toEqual(false);
    expect(wrapper.state().itemHovered).toEqual(undefined);
  });

  it('handleKeyDownDropDownItem fired', () => {
    const spy = sinon.spy(Select.prototype, 'handleKeyDownDropDownItem');
    const wrapper = shallow(
      <Select
          customLabel="Favorite Hockey Team"
          customHint="Please select your favorite hockey team."
          data={hockeyTeams}
      />);

    // TAB
    wrapper.find('.option-0').simulate('keydown', {keyCode : 9});
    expect(spy.calledOnce).toEqual(true);
    expect(Select.prototype.handleKeyDownDropDownItem.calledOnce).toEqual(true);

    // ENTER
    wrapper.find('.option-0').simulate('keydown', {keyCode : 32});
    expect(spy.calledTwice).toEqual(true);
    expect(Select.prototype.handleKeyDownDropDownItem.calledTwice).toEqual(true);

    // SPACEBAR
    wrapper.find('.option-0').simulate('keydown', {keyCode : 13});
    expect(spy.calledThrice).toEqual(true);
    expect(Select.prototype.handleKeyDownDropDownItem.calledThrice).toEqual(true);

  });

  it('handleKeyDownMenu fired', () => {
    const spy = sinon.spy(Select.prototype, 'handleKeyDownMenu');
    const wrapper = shallow(
      <Select
          customLabel="Favorite Hockey Team"
          customHint="Please select your favorite hockey team."
          data={hockeyTeams}
      />);

    // ENTER
    wrapper.find('.dropDownMenu').simulate('keydown', {keyCode : 32});
    expect(spy.calledOnce).toEqual(true);
    expect(Select.prototype.handleKeyDownMenu.calledOnce).toEqual(true);

    // SPACEBAR
    wrapper.find('.dropDownMenu').simulate('keydown', {keyCode : 13});
    expect(spy.calledTwice).toEqual(true);
    expect(Select.prototype.handleKeyDownMenu.calledTwice).toEqual(true);

    // DOWN ARROW
    // TODO: Error e.preventDefault is not a function
    // wrapper.find('.dropDownMenu').simulate('keydown', {keyCode : 40});
    // expect(spy.calledThrice).toEqual(true);
    // expect(Select.prototype.handleKeyDownMenu.calledTwice).toEqual(true);

  });

});

//tests not passing 3/10/17 DN
//tests fixed 3/14/17 CS
